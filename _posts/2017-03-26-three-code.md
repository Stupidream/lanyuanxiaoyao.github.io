---
layout: post
title: 原码、反码和补码
date: 2017-03-26 17:08
categories: Others
tags: [计算机组成原理]
---
# 概述
相信每一个学计算机的同学都头疼过原码,补码和反码这三个东西,甚至有时候还会冒出一个移码  
我们人类在计数的时候,用的都是十进制,但是计算机可不认这个,它们的世界用的是二进制来表示数,这个时候我们如果想要了解它们的世界是怎么样的,那么首先就要认识它们是怎么数数的

# 原码
## 概念
**原码(true form)** 是一种计算机中对数字的二进制定点表示方法.原码表示法在数值前面增加了一位符号位（即最高位为符号位）:正数该位为0,负数该位为1(**0有两种表示：+0和-0**),其余位表示数值的大小.  
数学表示如下  
若`!$X$`是纯整数:
```mathjax!
$$
[X]_原=
\begin{cases}
X & 0\le X\le 2^{n-1}-1\\
2^{n-1}+|X| & -(2^{n-1}-1)\le X\le 0
\end{cases}
$$
```
若`!$X$`是纯小数:
```mathjax!
$$
[X]_原=
\begin{cases}
X & 0\le X\lt 1\\
2^0+|X| & -1\lt X\le 0
\end{cases}
$$
```
数学公式看着就一脸懵逼,但是实际上并没有那么难理解,实际上就是说,如果我们的计算机里面用8个二进制位来表示一个数,那么最高位就作为符号位,剩下的7位二进制位表示数(空出来的位置补0),例如
```mathjax!
$$
[3]_原=00000011\\
[-3]_原=10000011
$$
```
## 表示范围
因为我们用了最高位来表示符号位,所以如果我们的计算机用`!$n$`位来表示一个数的话,那么我们实际用来表示数字大小的只有`!$n-1$`位,所以**有符号位原码**可以表示数的范围为
```mathjax!
$$
-2^{n-1}-1\sim+2^{n-1}-1
$$
```
事实上有时候我们不需要用到符号,所以我们也会有无符号数的存在,相应的也会有无符号原码,所以如果计算机用`!$n$`位来表示一个数的话,那么全部数位都用来表示数的大小,所以**无符号位原码**可以表示数的范围为
```mathjax!
$$
0\sim2^n-1
$$
```
## 优点
简单直观,例如,我们用8位二进制表示一个数,`+11`的原码为`00001011`,`-11`的原码就是`10001011`,非常接近我们平常的计数习惯,正数就在前面写个`+`,负数就在前面写个`-`

## 缺点
原码不能直接参加运算,可能会出错.例如数学上,`1+(-1)=0`,而在二进制中
`00000001+10000001=10000010`,换算成十进制为`-2`.显然出错了.  
所以原码的符号位不能直接参与运算,必须和其他位分开,这就增加了硬件的开销和复杂性

# 反码
## 概念
反码是数值存储的一种，但是由于补码更能有效表现数字在计算机中的形式，所以多数计算机一般都不采用反码表示数。  
反码表示法规定
- **正数**的反码与其原码相同
- **负数**的反码是对其原码逐位取反，但**符号位除外**

数学表示如下
若`!$X$`是纯整数:
```mathjax!
$$
[X]_反=
\begin{cases}
X & 0\le X\le 2^{n-1}-1\\
2^n-1+X & -(2^{n-1}-1)\le X\le 0
\end{cases}
$$
```
若`!$X$`是纯小数:
```mathjax!
$$
[X]_反=
\begin{cases}
X & 0\le X \lt 1\\
2-2^{-(n-1)}+X & -1\lt X\le 0
\end{cases}
$$
```
数学公式就是不如一个例子来得只管,所以举个例子,还是用8个二进制位表示一个数
```mathjax!
$$
正数\\
[3]_原=00000011\\
[3]_反=00000011\\
负数\\
[-3]_原=10000011\\
[-3]_反=11111100
$$
```
## 表示范围

# 补码
## 概念
在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理。此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。  
