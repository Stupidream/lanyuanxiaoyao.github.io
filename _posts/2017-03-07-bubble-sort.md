---
title: 冒泡排序
date: 2017-03-07 20:40
categories: 总结
tags: [总结,排序]
---
## 简介
冒泡排序是最经典也是最基本的排序，因为它的实现简单和直观，往往也是初学编程的时候接触得最多的一种算法。
## 步骤
假定有一个数组`[5,  7,  4,  10,  9]`，我们要把这个数组按从小到大排列
1. 我们从第一个数开始，两个一组进行比较大小，也就是把第一个数和第二个数比较，如果：
	- 第一个数比第二个数大，那么把这两个数交换
	- 第一个数比第二个数小，那么不进行任何操作
2. 在这个例子当中，`5`比`7`要小，那么我们不进行任何操作，然后开始比较下一组数，也就是第二数个和第三个数比较。
3. 还是同样的比较方法，这个时候，我们发现`7`比`4`大，那么我们几句交换这两个数的位置，数组就变成了`[5, 4, 7, 10, 9]`。
4. 然后开始比较第三个数和第四个数，依次类推……
5. 当我们比较完最后的两个数的时候，第一轮比较就已经完成了，我们可以发现，此时在数组最后的数是`10`，为什么会是`10`呢？因为我们在两两比较的时候，每次都会把较大的数交换到右边，如果一个数很大的话，那么它就会被不断交换，向右移动，直到遇到一个比它大的数为止，`10`是数列里最大的数，所以它会一直被交换移动到最右边才停下来，也就说，我们在第一轮操作中，就把数列里最大的数移到了最右边。
6. 接下来我们再对剩下的数进行同样的操作，还是从第一个数开始，但是因为`10`是已经被找出来的最大的数，我们第二轮就不需要对`10`再作比较了，也可以说`10`已经是有序的了，因为它的位置就是最后一位，因为它是整个数列中最大的数，这就等于我们第二轮操作的目标数列变成了`[5, 4, 7, 9]`
7. 还是按照第一轮的步骤，第二轮我们全部交换后得到的数列是`[4, 5, 7, 9]`。这一轮我们找到了第二大的数`9`，并让它交换到了最右边。
8. 然后进行第三轮，我们操作的数列是`[4, 5, 7]`。
9. 直到只剩下最后一个数的时候，我们的整个数列都是有序的了。

就好像冒泡泡一样，每一轮，数列里最大(最小)的数都好像泡泡一样浮到最上方，这就是冒泡排序。

## 代码实现
这是按从小到大排序的Java实现：
```java
public static int[] Sort(int num[]) {
	for (int i = 0; i < num.length - 1; i++) {
		for (int j = 0; j < num.length - 1 - i; j++) {
			if (num[j] > num[j + 1]) {
				int temp = num[j];
				num[j] = num[j + 1];
				num[j + 1] = temp;
			}
		}
	}
	return num;
}
```
冒泡排序的时间复杂度是`$$ O(n^2) $$`，空间复杂度是`$$ O(1) $$`
算法的实际时间与输入的数组有关，最好的情况是输入的数组是有序的，时间是`$$ O(1) $$`，最坏的情况是输入的数组是逆序的，时间就是`$$ O(n^2) $$`
```
$$
O(n^2)
$$
```
## 实际测试
数组大小(整数个数) | 运行时间(ms)
100|0
---|:--
1000|10
10000|160
100000|14706
可以看到时间是成指数倍增长的，到了100000级别的数据量的时候，冒泡排序就已经出现了肉眼可见的延迟了，效率十分低。

**测试相关代码**
```java
public static void main(String[] args) {
	int[] num = new int[1000000];
	Random r = new Random();
	for (int i = 0; i < num.length; i++) {
		num[i] = r.nextInt(Integer.MAX_VALUE);
	}
	int[] result;
	long start = System.currentTimeMillis();
	result = Sort(num);
	long end = System.currentTimeMillis();
	System.out.println("运行时间： " + (end - start) + "ms");
}
```
