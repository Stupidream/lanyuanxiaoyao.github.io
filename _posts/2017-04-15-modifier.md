---
layout: post
title: Java修饰符
date: 2017-04-15 14:22
categories: Java
tags: [Java]
---
# 梗概
Java提供了很多的修饰符，修饰符用于描述类/方法/变量的一些属性，主要分为两类
- 访问修饰符
- 非访问修饰符

# 访问修饰符
用于描述该类/方法/变量的被访问的权限，关键字有四个，权限范围如下：

| 修饰符    | 包外 | 子类 | 包内 | 类内 |
| --------- | ---- | ---- | ---- | ---- |
| public    | √   | √   | √   | √   |
| protected |      | √   | √   | √   |
| default   |      |      | √   | √   |
| private   |      |      |      | √   |

## public（公有访问修饰符）
被声明为 public 的类、方法、构造方法和接口能够被任何其他类访问。  
如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public 类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。  
++Java 程序的 main() 方法必须设置成公有的，否则，Java 解释器将不能运行该类。++

## protected（受保护的访问修饰符）
被声明为 protected 的变量、方法和构造器能被**同一个包**中的任何其他类访问，也能够被**不同包中的子类**访问。  
protected 访问修饰符**不能修饰类和接口**，方法和成员变量能够声明为 protected，但是**接口的成员变量和成员方法不能声明为 protected**。  
子类能访问 protected 修饰符声明的方法和变量，这样就能避免不相关的类使用这些方法和变量。  

## 不使用任何关键字（默认访问修饰符）
使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。**接口里的变量都隐式声明为public static final，接口里的方法默认情况下访问权限为public**。

## private（私有访问修饰符）
私有访问修饰符是最严格的访问级别，所以被声明为 private 的方法、**变量和构造方法只能被所属类访问**，并且**类和接口不能声明为 private**。  
声明为私有访问类型的变量只能通过类中公共的 getter 方法被外部类访问。  
Private 访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。  

## 注意
子类的类/方法/变量的权限修饰符的范围不能比父类的小
- 父类中声明为 public 的方法在子类中也必须为 public。
- 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。
- 父类中声明为 private 的方法，不能够被继承。

如下图，b类中的A方法范围比a类中的A方法访问权限范围更大
![](http://olwt21mf4.bkt.clouddn.com/17-4-15/84824545-file_1492238954686_d9a4.png)
如下图，如果b类中的A方法的修饰符改为private，那么就会报错
![](http://olwt21mf4.bkt.clouddn.com/17-4-15/69705924-file_1492239061720_337b.png)

# 非访问修饰符
为了实现一些其他的功能，Java 也提供了许多非访问修饰符。
- **static** 修饰符，用来创建类方法和类变量。
- **final** 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。
- **abstract** 修饰符，用来创建抽象类和抽象方法。
- **synchronized** 和 **volatile** 修饰符，主要用于线程的编程。

## static
被static修饰的类/方法/变量不属于类的实例，属于类本身
- 静态变量：
static关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static变量。
- 静态方法：
static关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。

对类变量和方法的访问可以直接使用 classname.variablename 和 classname.methodname 的方式访问。  
如下图，main方法中可以直接访问静态变量`s`和静态方法`print()`：  
![](http://olwt21mf4.bkt.clouddn.com/17-4-15/4876772-file_1492239938570_72fa.png)
事实上通过类名来访问该类中的静态变量之外，事实上类的实例也可以调用，如下图的写法也是正确的，尽管Java会给一个警告，因为Java不倡导大家这样使用：  
![](http://olwt21mf4.bkt.clouddn.com/17-4-15/12099555-file_1492239938679_29f1.png)

## final
final可以修饰类/方法/变量，具体规则如下
### final 变量
final 变量能被显式地初始化并且只能初始化一次。被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 **final 对象的引用不能改变，但是里面的值可以改变**。  
**举例**  
当我们试图更改final变量的值时候，Java会报错
![](http://olwt21mf4.bkt.clouddn.com/17-4-15/17188853-file_1492240334960_175d.png)
同样的，接下来的这个例子也会报错
![](http://olwt21mf4.bkt.clouddn.com/17-4-15/90587236-file_1492240694369_5f2f.png)
但是对`value`中的值可以随意改变
![](http://olwt21mf4.bkt.clouddn.com/17-4-15/90165029-file_1492240764709_15c5c.png)
final 修饰符通常和 static 修饰符一起使用来创建类常量。
### final 方法
类中的 final 方法可以被子类继承，但是不能被子类修改。  
声明 final 方法的主要目的是防止该方法的内容被修改。  
如下图，a类中的`final A()`方法可以被b类继承
![](http://olwt21mf4.bkt.clouddn.com/17-4-15/52182757-file_1492241013395_1415b.png)
但是当我们试图在b类中重写`final A()`时候，Java会报错
![](http://olwt21mf4.bkt.clouddn.com/17-4-15/78514708-file_1492241101451_12105.png)
### final 类
final 类不能被继承，没有类能够继承 final 类的任何特性。

## abstract
### 抽象类
抽象类不能用来实例化对象，声明**抽象类的唯一目的是为了将来对该类进行扩充**。  
**一个类不能同时被 abstract 和 final 修饰**。**如果一个类包含抽象方法，那么该类一定要声明为抽象类**，否则将出现编译错误。  
抽象类可以包含抽象方法和非抽象方法。  