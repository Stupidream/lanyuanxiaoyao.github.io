---
layout: post
title: 设计模式
date: 2017-07-13 08:19
categories: 设计模式
tags: [设计模式]
---

* content
{:toc}

# 简介
什么是设计模式呢？其实设计模式没有想象中那么高大上，设计模式其实就是以前的程序员大牛们长期编程总结下来的一些经验，也就是我们平常所说的最佳实现，换句话说就是按照这种方式来写我们的代码，会让我们的代码变得更加“优美”。  
这里“优美”的定义显然当然不是指我们的字写得漂亮，而是指我们的代码比较合理，更容易更改，更容易适应需求。  
我们可以需要一个更加专业一点的描述
> 在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学的。
> 设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。面向对象设计模式通常以类别或物件来描述其中的关系和相互作用，但不涉及用来完成应用的特定类别或物件。设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。
> 并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其它非设计模式的模式，如架构模式（英语：Architectural pattern）。同时，演算法不能算是一种设计模式，因为演算法主要是用来解决计算上的问题，而非设计上的问题。  
—— 维基百科

# 原则
说到设计模式，我们首先要先说设计模式的6个原则（也有归类为5个原则，其实理解意思就行了，差别不大），这6个原则是我们面向对象设计思想的精髓，设计模式其实就是这6个原则的具体实现和混合使用。
1. **开闭原则（Open Close Principle）**
开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。
2. **里氏代换原则（Liskov Substitution Principle）**
里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。
3. **依赖倒转原则（Dependence Inversion Principle）**
这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。
4. **接口隔离原则（Interface Segregation Principle）**
这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。
5. **迪米特法则（Demeter Principle）**
又称最少知道原则，最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。
6. **合成复用原则（Composite Reuse Principle）**
合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。

# 分类[^1x]
设计模式当然也有分类，这个分类是根据各个模式的功能来区分的，主要有5类（主要关注前面的3大类）：  
- 创建型模式（5种）
这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用新的运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。
	1. 工厂模式（Factory Pattern）
定义一个接口用于创建对象，但是让子类决定初始化哪个类。工厂方法把一个类的初始化下放到子类。
	2. 抽象工厂模式（Abstract Factory Pattern）
为一个产品族提供了统一的创建接口。当需要这个产品族的某一系列的时候，可以从抽象工厂中选出相应的系列创建一个具体的工厂类。
	3. 单例模式（Singleton Pattern）
确保一个类只有一个实例，并提供对该实例的全局访问。
	4. 建造者模式（Builder Pattern）
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
	5. 原型模式（Prototype Pattern）
用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
- 结构型模式（8种）
这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。
	1. 适配器模式（Adapter Pattern）
	2. 桥接模式（Bridge Pattern）
	3. 过滤器模式（Filter、Criteria Pattern）
	4. 组合模式（Composite Pattern）
	5. 装饰器模式（Decorator Pattern）
	6. 外观模式（Facade Pattern）
	7. 享元模式（Flyweight Pattern）
	8. 代理模式（Proxy Pattern）
- 行为型模式（12种）
这些设计模式特别关注对象之间的通信。
	1. 责任链模式（Chain of Responsibility Pattern）
	2. 命令模式（Command Pattern）
	3. 解释器模式（Interpreter Pattern）
	4. 迭代器模式（Iterator Pattern）
	5. 中介者模式（Mediator Pattern）
	6. 备忘录模式（Memento Pattern）
	7. 观察者模式（Observer Pattern）
	8. 状态模式（State Pattern）
	9. 空对象模式（Null Object Pattern）
	10. 策略模式（Strategy Pattern）
	11. 模板模式（Template Pattern）
	12. 访问者模式（Visitor Pattern）
- 额外的模式（2种）
	1. 并发型模式
	2. 线程池模式
- J2EE模式（8种）
这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。
	1. MVC模式（MVC Pattern）
	2. 业务代表模式（Business Delegate Pattern）
	3. 组合实体模式（Composite Entity Pattern）
	4. 数据访问对象模式（Data Access Object Pattern）
	5. 前端控制器模式（Front Controller Pattern）
	6. 拦截过滤器模式（Intercepting Filter Pattern）
	7. 服务定位器模式（Service Locator Pattern）
	8. 传输对象模式（Transfer Object Pattern）

我们主要关注前面3类共25种设计模式，它们的关系可以用一张图来表示：

![设计模式之间的关系](http://www.runoob.com/wp-content/uploads/2014/08/the-relationship-between-design-patterns.jpg)

# 思考
这里是关于设计模式的一些说法和思考
## 不要过度设计
设计模式的本质是一种经验！经验！！经验！！！说三遍！  
这种经验是以前的程序员总结下来的一种写代码的套路，但是我们都知道，条条大路通罗马，写出一手可以维护扩展性强的代码远不止一种方式，设计模式只是其中的一种，最忌讳的就是**为了设计模式而使用设计模式**，既然是经验，那么设计模式的最重要的意义就是用来**参考**，而不是照抄，当然这不是说即使某个设计模式能完美解决你的需求也不去用它，而是我们要合理地看待设计模式，最忌讳盲目地使用设计模式。  
举个例子，设计模式要解决的问题是需求的扩展，如果需求已经非常确定，某些功能是不需要扩展的，那我们为什么还要使用设计模式呢？  
正确对待设计模式的方式是了解它，并明确其中的思想，了解为什么这种模式可以解决这种问题，再在我们的实际编码中运用这种思想，不要陷入了过度设计的陷阱。

# 参考资料
1. [设计模式简介](http://www.runoob.com/design-pattern/design-pattern-intro.html)
2. [设计模式有何不妥，所谓的荼毒体现在哪？](https://www.zhihu.com/question/23757237)
3. [设计模式-维基百科](https://www.wikiwand.com/zh-hans/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F)

[^1x]: 我们常说的设计模式来源于“四人帮”（Gang of Four，GoF）编写的《设计模式：可复用面向对象软件的基础》（Design Patterns: Elements of Reusable Object-Oriented Software）一书，但我们知道，设计模式作为一种经验和最佳实践，肯定不止这本书中描述的20+种，世界上可以称为设计模式的模式千千万万，所以分类里面也加入了由麦克康奈尔（en:Steve McConnell）编写的《代码大全》（Code Complete）中描述的几种模式，当然还有一些被我们常用却没有被收录在书中的