---
layout: post
title: 单例模式（Singleton Pattern）
date: 2017-07-15 22:05
categories: 设计模式
tags: [设计模式,单例模式]
---

* content
{:toc}

# 小开端
关于单例模式其实我是没有准备这么早开始写的，不过确实是巧合，我这边刚好准备开始写单例模式，就遇到了一件和单例模式相关的小插曲，让我提前开始准备了单例模式的一些探讨，这个故事是这样的：  
> 今晚老大看我的项目框架，我在Demo里面写了一个关于Gson的单例，因为我们知道Gson没有提供静态方法，但是我们每次只是简单地把类转化为Json就要new一个Gson的实例，显然比较浪费，所以就写了一个单例，umm，我是这么写的

```java
public class GsonUtil {

	private static Gson gson = null;
	
	public Gson getGson () {
		if (gson == null) {
			gson = new Gson();
		}
		return gson;
	}
}
```
> 然后老大跟我说他也有一个Gson的单例模式，他是这样写的：

```java
public class Mygson {

	private static Gson instance = new GsonBuilder().setDateFormat("yyyy-MM-dd hh:mm:ss").create();
	
	public static Gson getInst() {
		return instance;
	}

}
```
> （忽略一些细节的差别，比如日期格式的设置和命名的不同）
> 然后老大说他的写法比较好，我的写法没有必要了，我愣了一下，难道单例模式也还有区别？

其实单例模式也是我接触地最多和最早的设计模式之一，而且我隐约记得单例模式还是无师自通的，因为应该是在哪一次项目中，觉得某个类到处new对象实在是太麻烦了，直觉到处new对象可能会造成资源的浪费，如果我可以new一个对象然后到处可以用就方便了，这就是我的单例模式的由来。  
关于我和老大的两种单例模式，我想了当时并没有反映过来，因为我的单例模式的写法用了很久，也没有深入去研究，我在回家的路上思考了一下，我关于这两种写法的想法初步是这样认为的：
- 老大的单例模式是在系统初始化的时候就构建了Gson的实例，然后每次调用都调用这个实例，那么会不会在系统初始化的时候因为某些原因构建失败导致实例为null，然后调用的时候整个系统每个调用的地方都会异常，导致系统有隐患？系统在使用的过程中如果出现了某些情况导致这个单例的实例被gc回收掉，那么单例无法重新创建，是不是也会造成隐患？因为这种单例的写法只构建一次Gson实例，**如果构建失败或者使用中被更改，那么这个实例不会再次被构建**。
- 我的单例的写法就没有上面的那个隐患，因为每次都会判断Gson实例是否存在，如果不存在就会重新new一个实例，但是，这样每次调用单例都会做一次判断，那么在大量**并发调用的时候会不会让系统的性能出现大幅度下降**？

基于这些疑问的存在，我对单例模式进行了一些研究。

# 简介
**单例模式（Singleton Pattern）** 是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。  
实现单例模式的思路是：一个类能返回对象一个引用 **(永远是同一个)** 和一个获得该实例的方法 **（必须是静态方法，通常使用getInstance这个名称）** ；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。

# 实现
单例模式的实现实际上是有很多种变种的方式，基本的两种是**懒汉式**和**饿汉式**，然后在这个的基础上扩展出适应多线程和其他条件的一些模式。
## 饿汉式
饿汉式单例模式就是我老大的那种实现方式，至于这个名字，可以想象一下一个很饿的人，一到了吃饭的时候就立刻吃到饱，一旦系统开始运行的时候，就立刻把类的实例构建出来，供方法调用。  
这个方式有两个特点：
- **不能延时加载**
顾名思义，在系统运行开始的时候就把实例构建好，而不是要用的时候才开始构建
- **线程安全**
即使在多线程的环境下，每个线程都只能拿到同一个实例，因为在多线程还没开始启动的时候，实例就已经构建好了。
```java
package singleton;

/**
 * 饿汉式单例模式
 *
 * @author lanyuanxiaoyao
 * @create 2017-07-14 23:10
 */
public class SingletonHungry {

    private static SingletonHungry instance = new SingletonHungry();

    public static SingletonHungry getInstance(){
        return instance;
    }

}
```

## 懒汉式
懒汉式单例模式就是我的那种实现方式，我们又想象一个很懒的人，等到要做事的时候才开始做事，从来不会提前准备，这就是懒汉式，等到了要使用这个实例的时候才开始构建实例，果然是很懒。  
这个方式也有两个特点：
- **实现了延迟加载**
这里的延迟，就是由饿汉式的一开始就加载好实例延迟到要用的时候才构建实例
- **线程安全但是系统开销大**
很好想象，我们在多线程环境下使用了`synchronized`关键字，如果没有这个关键字的话，那么在并发的情况下，后面的线程构建的实例就会覆盖前面的那个，造成线程不安全。除此之外，每次调用都要判断实例是否存在，在大量并发的情况下，会造成性能的降低。
```java
package singleton;

/**
 * 懒汉式单例模式
 *
 * @author lanyuanxiaoyao
 * @create 2017-07-14 23:15
 */

public class SingletonLazy {

    private static SingletonLazy instance = null;

    public static synchronized SingletonLazy getInstance() {
        if (instance == null) {
            instance = new SingletonLazy();
        }
        return instance;
    }

}
```