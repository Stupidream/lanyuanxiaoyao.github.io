---
layout: post
title: 插入排序(Insertion sort)
date: 2017-03-08 20:31
categories: 总结
tags: [总结,排序]
---
## 概念
> **插入排序(Insertion sort)** (又称直接插入排序)是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

## 步骤
1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
6. 重复步骤2~5

### 通俗解释
假定有一个数组`[5, 7, 4, 10, 9]`，我们要把这个数组按从小到大排列
1. 把数列看作两部分,前面部分是排序好的,后面部分是还没有排序的.
2. 我们先把第一个数看作是已经排序好的数列,因为只有一个数,所以它当然是有序的(对于有序数列来说),即看成`[5]`和`[7, 4, 10, 9]`两部分
3. 然后从第二个数开始,也就是从未排序数列的第一个数开始,将它从已排序数列的后(右)边开始(当然你也可以从前(左)边开始),分别与已排序数列的每一个数进行比较.
4. 如果发现比自己大的数,就与这个数交换位置,如果发现比自己小的数,就停止比较,开始下一轮操作,当然,如果已经交换到和数列的第一个数交换的时候,也开始下一轮操作.
5. 这个例子中,`7`和`5`比较,`7`比`5`大,所以不用交换,数列变成`[5, 7]`和`[4, 10, 9]`.
6. 重复这个步骤,知道所有未排序的数都被插入正确的位置.

插入排序的插入,意思就是我们维护一个新的数列,每次都把数插入到它正确的位置上.

## 代码实现
```java
private static int[] Sort(int[] num) {
    for (int i = 1; i < num.length; i++) {
        int j = i;
        while (j > 0 && num[j] < num[j - 1]) {
            int temp = num[j];
            num[j] = num[j - 1];
            num[j - 1] = temp;
            j--;
        }
    }
    return num;
}
```
## 复杂度分析
### 时间复杂度 $$O(n^2)$$
如果目标是把$$n$$个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。
- 最好的情况
序列已经是升序排列了，在这种情况下，需要进行的比较操作需$$(n-1)$$次即可
- 最坏的情况
序列是降序排列，那么此时需要进行的比较共有$${1\over2}n(n-1)$$次

插入排序的赋值操作是比较操作的次数加上$$(n-1)$$次。平均来说插入排序算法复杂度为$$O(n^2)$$。因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千，那么插入排序还是一个不错的选择。
### 空间复杂度 $$O(1)$$
直接插入排序是在原输入数组上进行后移赋值操作的（称"就地排序"），所需开辟的辅助空间跟输入数组规模无关，所以空间复杂度为:$$O(1)$$

## 实际测试
可以看到直接插入排序和选择排序相比,耗费的时间相差无几,但是我们之前说过选择排序没有优化空间,而插入排序还有优化的空间.

数组大小(整数个数) | 运行时间(ms)
100 | 0
1000 | 4
10000 | 43
100000 | 3929

## 优化
### 二分插入排序
#### 概念
对于直接插入排序中在有序数列中找到正确位置的这个步骤,可以用 **二分查找** 代替.以此来提升查找的效率,其他的步骤和直接插入排序的步骤是一样的.
#### 代码实现
```java
private static int[] Sort(int[] num) {
  for (int i = 1; i < num.length; i++) {
    int index = BinarySearch(num, num[i], i - 1);
    if (index != i) {
      int temp = num[i];
      for (int j = i - 1; j >= index; j--)
        num[j + 1] = num[j];
      num[index] = temp;
    }
  }
  return num;
}

private static int BinarySearch(int[] num, int target, int maxIndex) {
  int start = 0;
  int end = maxIndex;
  int middle = -1;
  int insertIndex = -1;

  while (start <= end) {
    middle = (start + end) / 2;
    if (num[middle] > target) {
      end = middle - 1;
    } else {
      start = middle + 1;
    }
  }
  return start;
}
```
#### 复杂度分析
##### 时间复杂度 $$O(n^2)$$
二分查找插入位置，因为不是查找相等值，而是基于比较查插入合适的位置，所以必须查到最后一个元素才知道插入位置。  
二分查找最坏时间复杂度：当$$2^x>=n$$时，查询结束，所以查询的次数就为$$x$$，而$$x$$等于$$log_2n$$.即$$O(log_2n)$$
所以，二分查找排序比较次数为：$$x=log_2n$$
##### 时间复杂度 $$O(1)$$
从实现原理可知，二分查找插入排序是在原输入数组上进行后移赋值操作的（称“就地排序”），所需开辟的辅助空间跟输入数组规模无关，所以空间复杂度为：$$O(1)$$

#### 实际测试
可以看到已经比直接插入排序的时间提升了不少.

数组大小(整数个数) | 运行时间(ms)
100 | 0
1000 | 3
10000 | 30
100000 | 2295

### 希尔排序
